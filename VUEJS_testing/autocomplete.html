<head>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
</head>

<!-- inspired by https://www.digitalocean.com/community/tutorials/vuejs-vue-autocomplete-component-->

<body>

    <style>
        .autocomplete {
            position: relative;
        }

        .autocomplete-results {
            padding: 0;
            margin: 0;
            border: 1px solid #eeeeee;
            height: 120px;
            min-height: 1em;
            max-height: 6em;
            overflow: auto;
        }

        .autocomplete-result {
            list-style: none;
            text-align: left;
            padding: 4px 2px;
            cursor: pointer;
        }

        .autocomplete-result.is-active,
        .autocomplete-result:hover {
            background-color: #4AAE9B;
            color: white;
        }
    </style>

    <div id="search">
        <input type="text" id="search_input" v-model="search" @input="OnChange" @keydown.tab.prevent="OnTab" @keydown.down.prevent="onArrowDown" @keydown.up.prevent="onArrowUp">
        <ul v-show="isOpen" class="autocomplete-results">
            <li :class="{ 'is-active': i === arrowCounter }" v-for="(result, i) in results_render" :key="i" class="autocomplete-result">
                {{ result }}
            </li>
        </ul>
    </div>

    <script>
        new Vue({
            el: '#search',
            data: {
                attributes: [{
                    name: 'test1',
                    type: 'int'
                }, {
                    name: 'test2',
                    type: 'string'
                }, {
                    name: 'test3',
                    type: 'int'
                }, {
                    name: 'test4',
                    type: 'date'
                }, {
                    name: 'test5',
                    type: 'string'
                }],
                tags: [{
                    name: 'tag1',
                    type: 'tag'
                }, {
                    name: 'tag2',
                    type: 'tag'
                }, {
                    name: 'tag3',
                    type: 'tag'
                }, {
                    name: 'tag4',
                    type: 'tag'
                }, {
                    name: 'tag5',
                    type: 'tag'
                }],
                number_operators: [{
                    name: '=',
                    type: 'number_operator'
                }, {
                    name: '>',
                    type: 'number_operator'
                }, {
                    name: '<',
                    type: 'number_operator'
                }, {
                    name: '>=',
                    type: 'number_operator'
                }, {
                    name: '<=',
                    type: 'number_operator'
                }, {
                    name: '!=',
                    type: 'number_operator'
                }],
                string_operators: [{
                    name: '=',
                    type: 'string_operator'
                }],
                results: [],
                results_render: [],
                isOpen: false,
                last_type: '',
                search: '',
                arrowCounter: 0,
                mode: 'attribute'
            },
            methods: {
                getIndexOfWord(wordlist, cursorPosition) {
                    var index = 0;
                    var i = 0;
                    for (i = 0; i < wordlist.length; i++) {
                        index += wordlist[i].length;
                        if (index >= cursorPosition) {
                            return i;
                        }
                        index += 1; //correction for space
                        if (index >= cursorPosition) {
                            return -1;
                        }
                    }

                },
                filterResults(event) {
                    this.mode = 'attribute';
                    keys = this.search.split(' ');
                    word_index = this.getIndexOfWord(keys, event.target.selectionStart);

                    if (word_index == -1) {
                        this.isOpen = false;
                        return;
                    }

                    last_key = keys[word_index];
                    this.results = [];
                    if (last_key.length == 0) {
                        this.isOpen = false;
                        return;
                    }

                    this.results = this.attributes.filter(item => {
                        //cut item
                        cuted_item = item.name.slice(0, last_key.length - 1);
                        if ('.'.concat(cuted_item) == last_key.toLowerCase()) {
                            return item;
                        }
                    });

                    this.results.push(...this.tags.filter(item => {
                        //cut item
                        cuted_item = item.name.slice(0, last_key.length - 1);
                        if ('#'.concat(cuted_item) == last_key.toLowerCase()) {
                            return item;
                        }
                    }));

                    this.results_render = this.results.map(item => item.name);
                    this.isOpen = true;
                    //this.results.push(this.tags.filter(item => '#'.concat(item).toLowerCase().indexOf(last_key[0].toLowerCase()) > -1));
                },
                InsertAtIndex(str, substring, index) {
                    return str.slice(0, index) + substring + str.slice(index);
                },
                OnTab(event) {
                    if (this.mode == 'attribute') {

                        keys = this.search.split(' ');

                        word_index = this.getIndexOfWord(keys, event.target.selectionStart);
                        last_key = keys[word_index];

                        if (last_key.length == 0) {
                            this.isOpen = false;
                            return;
                        }

                        selected = this.results[this.arrowCounter];

                        switch (selected.type) {
                            case 'int':
                            case 'string':
                            case 'date':
                                this.search = this.InsertAtIndex(this.search, '.'.concat(selected.name).slice(last_key.length), event.target.selectionStart);
                                this.isOpen = false;
                                this.SetCursorPos(event.target.selectionStart + '#'.concat(selected.name).slice(last_key.length).length);
                                break;
                            case 'tag':
                                this.search = this.InsertAtIndex(this.search, '#'.concat(selected.name).slice(last_key.length), event.target.selectionStart);
                                this.isOpen = false;
                                this.SetCursorPos(event.target.selectionStart + '#'.concat(selected.name).slice(last_key.length).length);
                                break;
                        }

                        switch (selected.type) {
                            case 'int':
                                this.results = this.number_operators;
                                this.results_render = this.number_operators.map(item => item.name);
                                this.mode = 'operator';
                                this.isOpen = true;
                                break;
                            case 'string':
                                this.results = this.string_operators;
                                this.results_render = this.string_operators.map(item => item.name);
                                this.mode = 'operator';
                                this.isOpen = true;
                                break;
                            case 'date':
                                this.results = this.number_operators;
                                this.results_render = this.number_operators.map(item => item.name);
                                this.mode = 'operator';
                                this.isOpen = true;
                                break;
                        }

                    } else if (this.mode == 'operator') {

                        selected = this.results[this.arrowCounter];
                        this.search = this.InsertAtIndex(this.search, ' '.concat(selected.name, ' '), event.target.selectionStart);
                        this.mode = 'attribute';
                        this.isOpen = false;
                        this.SetCursorPos(event.target.selectionStart + selected.name.length + 1);
                    }


                },
                SetCursorPos(pos) {
                    var search_input = document.getElementById('search_input');
                    this.$nextTick(() => {
                        search_input.focus();
                        search_input.setSelectionRange(pos, pos);
                    });
                },
                handleClickOutside(event) {
                    if (!this.$el.contains(event.target)) {
                        this.arrowCounter = -1;
                        this.isOpen = false;
                    }
                },
                onArrowDown() {
                    if (this.arrowCounter < this.results.length) {
                        this.arrowCounter = this.arrowCounter + 1;
                    }
                    if (this.arrowCounter >= this.results.length) {
                        this.arrowCounter = 0;
                    }

                },
                onArrowUp() {
                    if (this.arrowCounter > 0) {
                        this.arrowCounter = this.arrowCounter - 1;
                    }
                    if (this.arrowCounter < 0) {
                        this.arrowCounter = this.results.length - 1;
                    }
                },
                OnChange(event) {
                    this.filterResults(event);
                }
            }
        });
    </script>
</body>